# Using Docker

## Что такое контейнеры и для чего они нужны

Контейнеры коренным образом изменяют способ разработки, распространения и функционирования программного обеспечения. Контейнеры (containers) представляют собой средства инкапсуляции приложения вместе с его зависимостями.

Контейнеры обладают некоторыми преимуществами, обеспечивающими такие варианты использования, которые трудно или невозможно реализовать в обычных виртуальных машинах:
- контейнеры совместно используют ресурсы основной ОС, что делает их на порядок более эффективными
- переносимость контейнеров обеспечивает потенциальную возможность устранения целого класса программных ошибок
- упрощенная сущность контейнера означает, что можно одновременно запускать десятки контейнеров
- контейнеры предоставляют преимущества установки ПО без необходимости развертывания его в облаке

## Docker и контейнеры
Еще несколько десятков лет назад в Unix-системах существовала команда chroot, обеспечивающаяпростейшую форму изоляции части файловой системы. С 1998 года в ОС Free-BSD появилась утилита jail, распространяющая изоляционные возможности chroot на процессы. Компания Google начала разаработку CGroups для ядра ОС Linux и приступила к перемещению своей инфраструктуры в контейнеры. Проект Linux Containers (LXC) был создан в 2008 году и вскоре объединил CGroups, пространства имен ядра, технологию chroot и некоторые другие технологии, чтобы предоставить полностью завершенное решение по обеспечению контейнеризации. В 2013 году Docker стал последним штрихом в общей картине состояния
контейнеризации.

Платформа Docker состоит из двух отдельных компонентов: Docker Engine и Docker Hub
- **Docker Engine** предоставляет эффективный и удобный интерфейс для запуска контейнеров
- **Docker Hub** предоставля ет огромное количество образов контейнеров с открытым доступом для загрузки

## Первые шаги
```
docker run debian echo "Hello World"
```
- команда docker run инициализирует запуск контейнеров
- debian – это имя образа
- после загрузки и проверки образа Docker помещает его в работающий контейнер и выполняет заданную команду echo "Hello World" внутри контейнера

Можно запустить командную оболочку shell внутри контейнера, выполнив следующую команду:
```
docker run -i -t debian /bin/bash
```
- флаги -i и -t сообщают Docker, что необходимо создать сеанс интерактивной работы на подключаемом терминальном устройстве tty
- команда /bin/bash инициализирует командную оболочку bash
- при выходе из командной оболочки контейнер прекратит работу

**Основные команды**
- -h - задаем имя хоста
- docker ps - позволяет узнать подробности обо всех контейнерах, работающих в текущий момент
- docker ps -a - список всех контейнеров, включая остановленные
- docker inspect "id or name" - больше информации о конкретном контейнере
- - можно искать с утилитой grep или аргументом --format
```
docker inspect --format {{.NetworkSettings.IPAddress}} test_container
```
- docker diff "id or name" - выведет список файлов, измененных в работающем контейнере
- docker logs "id or name" - список всех событий, произошедших внутри заданного контейнера
- docker start "id or name" - запуск остановленного контейнера
- docker rm "id or name" - удаление контейнера
- docker rm -v $(docker ps -aq -f status=exited) - удалить все остановленные контейнеры
- - -v - позволяет удалить все тома (разделы), управляе мые Docker, на которые не ссылаются какие-либо другие контейнеры
- флаг --rm - удалияет остановленный контейнер и созданную на время его существования соответствующую файловую систему
```
docker run -it --name cowsay --hostname cowsay debian bash
docker commit cowsay test/cowsayimage
```
- docker commit "id or name" repositpry-name/image-name - превращения контейнера в образ, не имеет значения, работает контейнер или он остановлен

## Создание образов из файлов Dockerfile
**Dockerfile** – это обычный текстовый файл, содержащий набор операций, которые могут быть использованы для создания Docker-образа.
```
FROM debian:wheezy
RUN apt-get update && apt-get install -y cowsay fortune
```
- Инструкция FROM - определяет базовый образ ОС, является строго обязательной для всех файлов Dockerfile
- Инструкции RUN определяют команды, выполняемые в командной оболочке внутри данного образа
- docker build - создать образ, выполняется в том же каталоге, где расположен Dockerfile
```
docker build -t test/cowsay-dockerfile .
docker run test/cowsay-dockerfile /usr/games/cowsay "Moo"
```
- Инструкция ENTRYPOINT - позволяет определить выполняемый файл, который будет вызываться для обработки любых аргументов, переданных в команду docker run
```
ENTRYPOINT ["/usr/games/cowsay"]

docker build -t test/cowsay-dockerfile .
docker run test/cowsay-dockerfile "Moo"
```
Создадим скрипт для команды - /usr/games/fortune (если есть вводное значение - передаем его eсли нет то команду)
```
COPY entrypoint.sh /
ENTRYPOINT ["/entrtypoint.sh"]
```
- Инструкция COPY - копирует файл из файловой системы хоста в файловую систему образа, где первый аргумент определяет файл хоста, а второй – целевой путь

## Работа с реестрами
Реестры, репозитории, образы и теги
Для хранения образов применяется иерархическая система.
- реестр (registry) – сервис, отвечающий за хранение и распространение образов.
- репозиторий (repository) – набор взаимосвязанных образов 
- тег (tag) – алфавитно-цифровой идентификатор, присваиваемый образам внутри репозитория

- docker login - вход в реестр Docker Hub
- docker push имя/репозиторий - выгрузит образ
- docker pull имя/репозиторий - загрузит образ
- инструкцию MAINTAINER - информация, позволяющую связаться с автором данного образа
```
docker build -t amouat/cowsay:stable
```
Образу был автоматически присвоен тег latest. Чтобы определить свой тег, необходимо добавить его после имени
репозитория и символа двоеточия.

**Использование официального образа Redis**
```
docker pull redis
docker run --name myredis -d redis
```
- Аргумент -d - контейнер запустится в фоновом режиме
```
docker run --rm -it --link myredis:redis redis /bin/bash
redis-cli -h redis -p 6379
```
- команда --link - для установления соединения между контейнерами в сети. Docker получает информацию что нужно установить соединение между новым контейнером и существующим контейнером myredis, и в новом контейнере ссылка на существующий должна быть обозначена именем redis. Для этого Docker создает в файле нового контейнера **/etc/hosts** запись redis, указывающую на IP-адрес контейнера myredis.

**Тома (volumes)** – это файлы или каталоги, которые смонтированы непосредственно на хосте и не являются частью каскадно-объединенной файловой системы. Другие контейнеры могут совместно использовать их, и все изменения будут сразу же фиксироваться в файловой системе хоста. Существуют два способа объявления каталога как тома: 
- использование инструкции VOLUME в Dockerfile
- включение флага -v в команду docker run
```
VOLUME /data
docker run -v /data test/webserver
```
По умолчанию заданный каталог или файл будет смонтирован на хосте внутри каталога, в котором был установлен Docker (обычно это каталог /var/lib/docker/).

Резервных копия контейнера Redis
```
docker run --rm --volumes-from myredis -v $(pwd)/backup:/backup debian cp /data/dump.rdb /backup/
```
- аргумент -v использован для монтирования известного нам существующего каталога хоста
- аргумент --volumes-from – для установления соединения между новым контейнером и каталогом базы данных Redis

## Основы Docker
**Архитектура Docker**
- в центре расположен демон Docker (Docker daemon), ответственный за создание, запуск и контроль работы контейнеров, а также за создание и хранение образов. Запускается командой docker daemon.
- клиент Docker, используется для диалога с демоном Docker по протоколу HTTP. По умолчанию это соединение устанавливается через сокет домена Unix
- реестры Docker используются для хранения и распространения образов. Реестромпо умолчанию, явялется Docker Hub

**Базовые технологии**

Демон Docker использует «драйвер выполнения» для создания контейнеров. По умолчанию выбирается собственный драйвер Docker runc - он очень тесно связан со следующими механизмами ядра:
- cgroups – механизм, отвечающий за управление ресурсами, используемыми контейнером. Обеспечивает выполнение операций «замораживания» (freezing) и «размораживания» (unfreezing) контейнеров как поддержку функциональности команды docker pause;
- пространства имен ( namespaces) отвечают за изоляцию контейнеров, гарантируют, что файловая система, имя хоста, пользователи, сетевая среда и процессы любого контейнера полностью отделены от остальной части системы.
Еще одной основополагающей технологией для Docker является файловая система с каскадно-объединенным монтированием (Union File System – UnionFS), обеспечивающая хранение уровней для контейнеров.

**Сопровождающие технологии**
- Swarm – решение задачи кластеризации от Docker. Swarm позволяет сгруппировать несколько Docker-хостов, после чего пользователь может работать с этой группой как с единым ресурсом
- Docker Compose – инструмент для создания и выполнения приложений, скомпонованных из нескольких Docker-контейнеров
- Docker Machine устанавливает и конфигурирует Docker-хосты на локальных и удаленных ресурсах
- Kitematic представляет собой графический пользовательский интерфейс для операционных систем Mac OS и Windows, обеспечивающий запуск и управление контейнеров Docker
- Docker Trusted Registry – локально устанавливаемое программное решение для хранения и управления образами Docker
## Как создаются образы
**Контекст создания образа**
Для команды docker build необходим Dockerfile и контекст создания образа (build context) (который может быть пустым). Контекст создания – это набор локальных файлов и каталогов, к которым можно обращаться из инструкций ADD и/или COPY в Dockerfile. В качестве контекста создания образа разрешается указывать git-репозиторий. Docker воспринимает контекст как git-репозиторий, если переданный путь начинается с префиксов github.com/, git@ или git://.
Docker способен принимать входные данные из стандартного потока ввода STDIN, если в команде указать аргумент "-" вместо контекста создания образа. Входными данными может быть либо Dockerfile без контекста(например, docker build - < Dockerfile), либо архивный файл, содержащий контекст, в том числе и Dockerfile (например, docker build - < context.tar.gz).

**Уровни образа**

Каждая инструкция в Dockerfile приводит к появлению нового уровня (layer) образа. Новый уровень создается во время запуска контейнера с использованием образа предыдущего уровня при выполнении соответствующей инструкции Dockerfile и с сохранением нового образа. После успешного завершения выполнения инструкции Dockerfile вспомогательный контейнер удаляется, если в команде не был задан аргумент --rm=false1.
```
docker history test:latest
```
docker history - покажет набор уровней, формирующих образ

**Кэширование**

Для ускорения создания образов Docker выполняет кэширование каждого уровня. Кэширование очень важно для повышения эффективности рабочих операций, но не всегда его применение имеет смысл. Кэширование используется для инструкций при следующих условиях:
- в кэше была обнаружена предыдущая инструкция
- в кэше имеется уровень, который имеет в точности ту же инструкцию и предшествующий родительский уровень
Для инструкций COPY и ADD кэш считается некорректным, если изменилась контрольная сумма или метаданные для любого файла. Для сохраняемых в кэше инструкций RUN не гарантируется получение одинакового результата при многократных повторных вызовах.
- аргемент --no-cache - запретить кэширование

**Базовые образы**
  
Размер образа можно уменьшить до предельной величины и формировать образы только из бинарных файлов. Для этого необходим Dockerfile из специального образа **scratch** (абсолютно пустая файловая система). Бинарные файлы просто копируются в файловую систему создаваемого образа, а соответствующие инструкции CMD записываются в Dockerfile. Для бинарных файлов нужно включить в образ все требуемые библиотеки.

**Инструкции Dockerfile**

- ADD - Копирует файлы из контекста создания или из удаленных URL-ссылок в создаваемый образ. Если архивный файл добавляется из локального пути, то он будет автоматически распакован. Так как диапазон функциональности инструкции ADD достаточно велик, в общем случае лучше воспользоваться более простой командой COPY для копирования файлов и каталогов в локальном контексте создания или инструкциями RUN с запуском curl или wget для загрузки удаленных ресурсов (с сохранением возможности обработки и удаления результатов загрузки в той же самой инструкции).
- CMD - Запускает заданную инструкцию во время инициализации контейнера. Если была определена инструкция ENTRYPOINT, то заданная здесь инструкция будет интерпретироваться как аргумент для ENTRY POINT (в этом случае необходимо использовать формат exec). Инструкция CMD замещается любыми аргументами, указанными в команде docker run после имени образа.
- COPY - Используется для копирования файлов из контекста создания в образ. Имеет два формата: COPY источник цель и COPY ["источник", "цель"] – оба копируют файл или каталог из «источник» в контексте создания в «цель» внутри контейнера. Формат JSON-массива обязателен, если путь содержит пробелы. Можно использовать шаблонные символы для определения нескольких файлов или каталогов. Следует обратить особое внимание на невозможность указания путей «источника», расположенных вне пределов контекста создания (например, нельзя указать для копирования файл ../another_dir/myfile).
- ENTRYPOINT - Определяет выполняемый файл (программу) (и аргументы по умолчанию), запускаемый при инициализации контейнера. В эту выполняемую программу передаются как аргументы любые инструкции CMD или аргументы команды docker run, записанные после имени образа. Инструкции ENTRYPOINT часто используются для организации скриптов запуска, которые инициализируют переменные и сервисы перед обработкой всех передаваемых в образ аргументов.
- ENV - Определяет переменные среды внутри образа. На эти переменные можно ссылаться в последующих инструкциях. Определенные в этой инструкции переменные будут доступными также и внутри образа.
- EXPOSE - Сообщает механизму Docker о том, что в данном контейнере будет существовать процесс, прослушивающий заданный порт или несколько портов. Механизм Docker использует эту информацию при установлении соединения между контейнерами (см. раздел «Соединение между контейнерами» ниже) или при открытии портов для общего доступа при помощи аргумента -P в команде docker run. Но сама по себе инструкция EXPOSE не оказывает никакого воздействия на сетевую среду.
- FROM - Определяет основной образ для файла Dockerfile. Все последующие инструкции выполняют операции создания поверх заданного образа. Основной образ определяется в форме IMAGE:TAG (например, debian:wheezy). При отсут- ствии тега по умолчанию полагается latest, но я настоятельно рекомендую всегда явно указывать тег конкретной версии, чтобы избежать неприятных неожиданностей. Эта инструкция обязательно должна быть самой первой в Dockerfile.
- MAINTAINER - Определяет метаданные об авторе «Author» для создаваемого образа в заданной строке. Извлечь эти метаданные можно с помощью команды docker inspect -f {{.Author}} IMAGE. Обычно используется для записи имени автора образа и его контактных данных.
- ONBUILD - Определяет инструкцию, которая должна выполняться позже, когда данный образ будет использоваться как основной уровень для другого образа. Это может оказаться полезным при обработке данных, добавляемых в образ-потомок (например, это может быть инструкция копирования дополнительного кода из заданного каталога и запуска скрипта сборки, обрабатывающего скопированные данные).
- RUN - Запускает заданную инструкцию внутри контейнера и сохраняет результат.
- USER - Задает пользователя (по имени или по идентификатору UID) для использования во всех последующих инструкциях RUN, CMD, ENTRYPOINT. Отметим, что идентификаторы UID одинаковы на хосте и в контейнере, но имена пользователей могут присваиваться различным идентификаторам UID, что может приводить к затруднениям при установке прав доступа.
- VOLUME - Объявляет заданный файл или каталог как том. Если такой файл или каталог уже существует в образе, то он копируется в том при запуске контейнера. Если задано несколько аргументов, то они интерпретируются как определение нескольких томов. Из соображений обеспечения безопасности и сохранения переносимости нельзя определить каталог хоста как том внутри файла Dockerfile. 
- WORKDIR - Определяет рабочий каталог для всех последующих инструкций RUN, CMD, ENTRYPOINT, ADD, COPY. Инструкцию можно использовать несколько раз. Допускается указание относительных путей, при этом итоговый путь определяется относительно ранее указанного рабочего каталога WORKDIR.

## Установление связи контейнеров с внешним миром
Открыть нужные порты для общего доступа с помощью аргументов -p или -P в команде запуска
```
docker run -d -p 8000:80 nginx
```
- Аргумент -p 8000:80 сообщил механизму Docker о необходимости перенаправления порта 8000 хоста на порт 80 в контейнере
- аргумента -P механизм Docker должен автоматически выбрать свободный порт для перенаправления с хоста в контейнер
```
$ docker port $(docker run -d -P nginx) 80
```
**Соединение между контейнерами**

Соединения (links) механизма Docker – простейший способ обеспечения обмена информацией между контейнерами на одном хосте. При использовании принятой по умолчанию сетевой модели Docker обмен данными между контейнерами будет происходить во внутренней сети Docker, то есть все коммуникационные операции останутся невидимыми из сети хоста.

Соединения инициализируются с помощью аргумента --link CONTAINER:ALIAS в команде docker run, где CONTAINER – имя контейнера-адресата (link container), а ALIAS – локальное имя, используемое внутри управляющего контейнера для обращения к контейнеру-адресату. Кроме того, при использовании соединений Docker внутреннее имя и идентификатор контейнера-адресата будут добавлены в файл /etc/hosts в управляющем контейнере, что позволит обращаться по этому имени к контейнеру-адресату из управляющего контейнера.

По умолчанию контейнеры могут обмениваться информацией друг с другом вне зависимости от того, было ли установлено соединение в явной форме. Если нужно запретить эту возможность, воспользуйтесь аргументами --icc=false и --iptables при запуске демона Docker. В этом случае при установлении соединения Docker будет применять правила Iptables, чтобы разрешить контейнерам обмен информацией через любые порты, которые были объявлены открытыми.

Контейнер-адресат обязательно должен быть инициализирован раньше управляющего контейнера, то есть двунаправленное соединение установить невозможно.

## Управление данными с помощью томов и контейнеров данных
Тома (volumes) Docker – это каталоги, которые не являются частью файловой системы UnionFS конкретного контейнера,
а представляют собой обычные каталоги в файловой системе хоста, но могут быть смонтированы как отдельные файловые системы. Существуют три различных способа инициализации томов. Важно хорошо понимать различия между этими способами. - Во-первых, можно объявить том при запуске контейнера с помощью флага -v:
```
docker run -it --name container-test -h CONTAINER -v /data debian /bin/bash
```
- Второй способ – объявление тома с помощью инструкции VOLUME в файле Dockerfile:
```
FROM debian:wheezy
VOLUME /data
```
- Третий способ состоит в расширении аргумента -v команды docker run с явным указанием связываемого каталога хоста в формате -v HOST_DIR:CONTAINER_DIR. Этот способ нельзя использовать в Dockerfile (так как он нарушает принцип переносимости и создает угрозу безопасности).
```
$ docker run -v /home/adrian/data:/data debian ls /data
```
**Совместное использование данных**

Синтаксис с использованием ключа -v HOST_DIR:CONTAINER_DIR очень удобен для совместного использования файлов хостом и одним или несколькими контейнерами. Например, файлы конфигурации могут храниться на хосте и монтироваться внутри контейнеров, создаваемых из однотипных образов. Также можно совместно пользоваться одними и теми же данными в нескольких контейнерах, если указать ключ --volumes-from CONTAINER в команде docker run.Важно отметить, что этот способ работает вне зависимости от того, активен ли в текущий момент контейнер, содержащий тома

**Контейнеры данных**

Контейнеры данных (data containers) - единственной целью которых является обеспечение совместного использования данных несколькими контейнерами. Главное преимущество такого подхода состоит в предоставлении удобного пространства имен для томов, загружаемых просто с помощью ключа --volumes-from в команде docker run.

## Часто используемые команды Docker
- Команда run - docker run – это команда запуска новых контейнеров
- - -a, --attach - Подключает заданный поток (STDOUT и прочие) к терминалу
  - -d, --detach - Запускает контейнер в режиме «отключения от всех потоков
  - -i --interactive - Поддерживает доступность открытого потока stdin
  - --restart - Позволяет настроить образ действий при попытке Docker перезапустить оста- новленный контейнер.
  - --rm - Автоматически удаляет контейнер после завершения сеанса его работы
  - -t, --tty - Создает псевдоустройство TTY (терминал)
  - -e, --env - Определяет переменные среды внутри контейнера
  - -h --hostname - Устанавливает для запускаемого контейнера заданное имя Unix-хоста
  - --name NAME - Присваивает контейнеру имя NAME
  - -v, --volume - 2 формы записи - Первая форма определяет только каталог внутри контейнера, а связываемый с ним каталог хоста выбирает механизм Docker. Вторая форма определяет как внутренний каталог контейнера, так и связываемый с ним каталог хоста
  - --volumes-from -Монтирует тома из заданного контейнера
  - --expose - Аналог инструкции EXPOSE из файла Dockerfile. Определяет номер порта или диапазон номеров портов, предназначенных для использования в контейнере, но в действительности не открывает каких-либо портов.
  - --link - Настраивает интерфейс частной закрытой сети для заданного контейнера
  - -p --publish - «Публикует» порт данного контейнера, то есть делает его доступным с хоста
  - -P, --publish-all - Объявляет все порты, открываемые в контейнере, доступными на хосте. Для каждого объявляемого порта произвольным образом выбирается свободный порт с большим номером
  - --entrypoint - Определяет точку входа для запускаемого контейнера в соответствии с заданным аргументом, заменяя содержимое любой инструкции ENTRYPOINT из Dockerfile
  - -u, --user - Определяет пользователя, от имени которого выполняются команды
  - -w, --workdir - Устанавливает рабочий каталог в контейнере в соответствии с заданным путевым именем. Заменяет любые значения, определенные в файле Dockerfile.

**Управление контейнерами**
- docker attach [OPTIONS] CONTAINER - Команда attach позволяет пользователю наблюдать или взаимодействовать с основным процессом внутри контейнера
- docker create - Создает контейнер из заданного образа, но не запускает его
- docker cp - Позволяет копировать файлы между файловыми системами контейнера и хоста
- docker exec - Запускает заданную команду внутри контейнера
- docker kill - Посылает сигнал основному процессу (PID=1) в контейнере
- docker pause - Временно приостанавливает все процессы внутри заданного контейнера
- docker restart - Перезапускает один или несколько контейнеров
- docker rm - Удаляет один или несколько контейнеров
- docker start - Запускает остановленный контейнер
- docker stop - Останавливает (но не удаляет) один или несколько контейнеров
- docker unpause - Перезапускает контейнер, выполнение которого было приостановлено командой docker pause

**Информация о механизме Docker**
- docker info - Выводит различную информацию о системе Docker и хосте
- docker help - Выводит информацию об использовании и справку
- docker version - Выводит информацию о версии клиента и сервера Docker

**Информация о контейнере**
- docker diff - Показывает изменения в файловой системе контейнера по сравнению с файловой системой образа
- docker events - Выводит в реальном времени события от демона демону
- docker inspect - Предоставляет подробную информацию о заданных контейнерах или образах
- docker logs - Выводит журналы (logs) для контейнера
- docker port - Выводит список отображений открытых портов для заданного контейнера
- docker ps - Предоставляет общую информацию о работающих контейнерах: имя, идентификатор, состояние
- docker top - Предоставляет информацию о процессах, выполняющихся внутри заданного контейнера

**Работа с образами**
- docker build - Создает образ из файла Dockerfile
- docker commit - Создает образ из указанного контейнера
- docker export - Экспортирует содержимое файловой системы заданного контейнера в виде tar-архива, направляя его в стандартный поток вывода STDOUT
- docker history - Выводит информацию о каждом уровне в образе
- docker images - Выводит список локальных образов, содержащий такую информацию, как имя репозитория, имя тега, размер и др
- docker import - Создает образ из архивного файла, содержащего файловую систему и созданного командой docker export
- docker load - Загружает репозиторий из tar-архива, передаваемого через стандартный поток ввода STDIN
- docker rmi - Удаляет заданный образ или несколько образов
- docker save - Сохраняет именованные образы или репозитории в tar-архив, передаваемый в стандартный поток вывода STDOUT
- docker tag - Связывает имя репозитория и тега с заданным образом

**Команды для работы с реестром**
- docker login - Выполняет процедуру регистрации или входа на заданный сервер реестра
- docker logout - Выполняет процедуру выхода из реестра Docker
- docker pull - Загружает заданный образ из реестра
- docker push - Выгружает образ или репозиторий в заданный реестр
- docker search - Выводит список общедоступных репозиториев из реестра Docker Hub, соответствующих заданному шаблону поиска

## Автоматизация с использованием Compose
Инструмент Docker Compose ( http://docs.docker.com/compose/) предназначен для быстрой настройки и запуска различных вариантов сред разработки Docker.
- up - Запуск всех контейнеров, определенных в Compose-файле
- build - Пересоздание всех образов, созданных из файлов Dockerfile
- ps - Вывод информации о состоянии контейнеров, управляемых Compose
- run - Одноразовый запуск контейнера с выполнением одной команды, Также запускаются все контейнеры, с которыми должны быть установлены соединения
- logs - Вывод журнальных записей с цветной подсветкой, объединенный для всех контейнеров, управляемых Compose
- stop - Останов контейнеров без их удаления
- rm - Удаление остановленных контейнеров

## Распространение образов
**Именование образов и репозиториев**
```
docker build -t "identidock:0.1" .
docker tag "identidock:0.1" "amouat/identidock:0.1"
```
Имена и теги присваиваются при создании образа или устанавливаются специальной командой dockertag. Имя тега должно состоять из букв верхнего и нижнего регистров, чисел и символов «точка» (.) и «дефис» (-). Длина имени тега – от 1 до 128 символов.

**Docker Hub** – реестр, работающий в режиме онлайн и поддерживаемый компанией Docker Inc.
```
docker tag identidock:latest amouat/identidock:0.1
docker push amouat/identidock:0.1
```
Требуемая обязательная форма <username>/<repositoryname>, где <username>– имя вашей учетной записи в реестре Docker Hub, а <repositoryname> – имя репозитория, который должен существовать в реестре Hub. Если указанный репозиторий не существовал ранее, то он создается, и выполняется выгрузка образа с учетом заданного тега.

**Организация собственного реестра**
```
docker run -d -p 5000:5000 registry:2
```
Частный реестр представляет собой приложение с открытым исходным кодом, работающее на локальной системе. Простейшим способом создания локального реестра является использование официального образа.
```
docker push localhost:5000/identidock:0.1
```
Реестр сгенерировал аутентификационный дайджест (digest) для этого образа. Это уникальное хэш-значение на основе содержимого образа и его метаданных. Образы можно извлекать из реестра по дайджесту, например:
```
docker pull localhost:5000/identidock@sha256:d20affe522a3c6ef1f8293de69fea5a8621d695619955262f3fc28852e173108
```
Главное обоснование использования собственного частного реестра – необхо- димость организации централизованного хранилища для группы разработчиков или для всей организации.

Демон Docker запретил соедине- ние с удаленным хостом, так как этот хост не имеет действительного сертификата TLS (Transport Layer Security), решение:
- Перезапустить каждый демон Docker, с аргументом --insecure-registry 192.168.1.100:5000
- Установить на хосте реестра подписанный сертификат от аккредитованного центра сертификации
- Установить на хосте реестра самоподписанный сертификат и скопировать его на все хосты демонов Docker

**Сокращение размера образа**

Во многих случаях следует попытаться уменьшить размеры образов.
```
RUN apt-get update \
&& apt-get install -y curl numactl && rm -rf /var/lib/apt/lists/*
```
- Чистим
- Выбор образа с минимальным размером

## Непрерывная интеграция и тестирование с использованием Docker
Docker и Jenkins для создания рабочего потока непрерывной интеграции (continuous integration – CI). Jenkins – это широко известный сервер непрерывной интеграции с открытым исходным кодом. Нужно настроить сервер Jenkins таким образом, чтобы при любых изменениях он автоматически проверял внесенные изменения, создавал новые образы и вы- полнял для них определенные операции тестирования.тобы контейнер Jenkins мог формировать образы, необходимо смонтировать размещенный на хосте Docker-сокет1 внутри контейнера, тем самым позволяя серверу Jenkins успешно создавать образы-«братья» того же уровня.

**Тестирование и микросервисы**
- модульные тесты (юнит-тесты) – для каждого сервиса необходимо иметь полный набор модульных тестов, которые должны проверять правильную функциональность небольших, изолированных частей приложения
- тесты компонентов – это может быть тестирование на уровне внешнего ин- терфейса отдельных сервисов или тестирование на уровне подсистемы, со- стоящей из группы сервисов
- тесты для системы в целом – эти тесты подтверждают работоспособность всей системы

Дополнительных компонентов
- тесты по договору с заказчиком (потребителем) – эти тесты, также называе- мые контрактами, управляемыми заказчиком, формируются потребителем или заказчиком сервиса и предназначены главным образом для опреде- ления ожидаемых входных и выходных данных
- интеграционные тесты – это тесты для проверки правильности работы ка- налов обмена информацией между всеми компонентами системы
- тестирование по расписанию - выполнение подобных тестов можно запланировать на ночное (нерабочее) время

Многие из перечисленных выше тестов можно классифицировать как дореест- ровые (preregistry) и послереестровые (postregistry) в зависимости от того, выпол- няются ли они до или после добавления образа в реестр.

**Тестирование в процессе эксплуатации**
- Одну из самых распространенных методик иногда называют blue/green-развертывание (blue/green deployment). Например, нужно обновить существующий работающий сервис (назовем его blue-версией), заменив его новой версией – green- версией.
- По методике A/B, или многовариантном тестировании (multivariate testing), две (и более) версии сервиса работают вместе в течение тестового периода
- Cкрытого развертывания (shadowing) обе версии сервиса отвечают на все запросы, но реально используются только результаты, получаемые от старой, стабильной версии



