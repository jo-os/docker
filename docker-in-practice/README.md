## Знакомство с Docker
**Docker** – это платформа, которая позволяет «создавать, поставлять и запус­ кать любое приложение повсюду»

**Чем хорош Docker?**
- Замена виртуальных машин
- Прототипирование программного обеспечения
- Упаковка программного обеспечения
- Возможность для архитектуры микросервисов
- Моделирование сетей
- Возможность производительности полного стека в автономном режиме
- Сокращение неизбежных расходов на отладку
- Документирование зависимостей программного обеспечения и точки взаимодействия
- Возможность непрерывной доставки

**Ключевые команды Docker**

**Основная функция Docker** – создавать, отправлять и запускать программное обеспечение в любом месте, где есть Docker.
- docker build - Собрать образ Docker
- docker run - Запустить образ Docker в качестве контейнера
- docker commit - Сохранить контейнер Docker в качестве образа
- docker tag - Присвоить тег образу Docker

**Способы создания нового образа Docker**
- Команды Docker/ «От руки»
- Dockerfile – это текстовый файл, содержащий серию команд
- Dockerfile и инструмент управления конфигурацией
- Стереть образ и импортировать набор файлов

## Постигаем Docker
**Архитектура Docker**

Docker на хост­компьютере разделен на две части: **демон** с прикладным программным интерфейсом RESTful и **клиент**, который общается с демоном. Вы вызываете Docker ­клиент, чтобы получить информацию или дать инструкции демону. Демон – это сервер, который получает запросы и возвращает ответы от клиента по протоколу HTTP. Частный **реестр** Docker – это сервис, который хранит образы Docker.

## Демон Docker - контролирует доступ к Docker на вашем компью- тере, управляет состоянием контейнеров и образов, а также взаимодействует с внешним миром.

### Запустите демон Docker с открытым TCP адресом.
```
sudo docker daemon -H tcp://0.0.0.0:2375
определяет хост­сервер с помощью флага ­H, использует протокол TCP,
открывает все IP- интерфейсы (с 0.0.0.0) и стандартный порт сервера Docker (2375).
```
Подключиться снаружи
```
docker -H tcp://<your host's ip>:2375 <subcommand>
```
через переменную среды DOCKER_HOST
```
export DOCKER_HOST=tcp://<your host's ip>:2375
docker <subcommand>
```
### Запустить контейнер Docker в фоновом режиме как службу
- Используйте флаг -d в команде docker run 
```
docker run -d -i -p 1234:1234 --name daemon ubuntu:14.04 nc -l 1234
```
- Флаг -d запускает контейнер в качестве демона.
- Флаг -i дает этому контейнеру возможность взаимодействовать с вашим сеансом Telnet.
- С помощью флага -p вы «публикуете» порт 1234 из контейнера на хост.
- Флаг --name позволяет присвоить контейнеру имя, чтобы вы могли обратиться к нему позже.
- В конце вы запускаете простой прослушивающий эхо­сервер на порту 1234 с помощью netcat (nc).

Параметры флагов повторного запуска Docker:
- no - Не перезапускать при выходе контейнера
- always - Всегда перезапускать при выходе контейнера
- unless-stopped - Всегда перезагружать, но помнить о явной остановке
- on-failure[:max-retry] - Перезапускать только в случае сбоя
```
docker run -d --restart=always ubuntu echo don
```
### Перемещение Docker в другой раздел
Запустите демон Docker, указав новое местоположение с помощью флага -g
```
dockerd -g /home/dockeruser/mydocker
```
## Клиент Docker
Это то,что вы запускаете, когда набираете такие команды,как docker run или docker pull насвоем компьютере. Его задача - взаимодействовать сдемоном Docker посредством HTTP­запросов.

### Использование socat для мониторинга трафика Docker API
Надо отладить проблему с помощью команды Docker

Используйте программу для контроля сетевого трафика, чтобы проверять API­вызовы и создавать свои собственные.
```
socat -v UNIX-LISTEN:/tmp/dockerapi.sock,fork UNIX-CONNECT:/var/run/docker.sock &
```
- В этой команде -v делает вывод читаемым с указанием потока данных.
- Часть UNIX-LISTEN говорит socat прослушивать сокет Unix
- fork гарантирует, что socat не завершит работу после первого запроса
- UNIX-CONNECT сообщает socat подключиться к Unix­сокету Docker
- & указывает, что команда выполняется в фоновом режиме

Весь трафик, проходящий в каждом направлении, socat будет видеть, и он будет зарегистрирован на вашем терминале.

### Использование Docker в браузере
Запустите демон Docker с открытым портом и задействуйте совместное использование ресурсов между разными источниками, а затем обслуживайте репозиторий Docker­ терминала на выбранном вами веб­сервере.
```
git clone https://github.com/aidanhs/Docker-Terminal.git
cd Docker-Terminal
python2 -m SimpleHTTPServer 8000
```
### Использование портов для подключения к контейнерам
Флаг ­p для отображения порта контейнера в свой хост-­компьютер.
```
docker rnu -d -p 10001:80 --name blog1 tutum/wordpress
```
### Разрешение связи между контейнерами
Разрешить связь между контейнерами для внутренних целей.
- Используйте пользовательские сети, чтобы контейнеры могли взаимодействовать друг с другом.
```
docker network create my_network
```
По умолчанию все контейнеры, которые вы подключаете к этой сети, смогут видеть друг друга по их именам.
```
docker network connect my_network blog1
docker run -it --network my_network ubuntu:16.04 bash
```
### Установление соединений между контейнерами для изоляции портов
Старый метод объяв­ления обмена данными между контейнерами – флаг соединений Docker.
- Установление соединений позволяет инкапсулировать и определять отношения между контейнерами, не подвергая сервисы сети хоста
```
docker run --name wordpress --link wp-mysql:mysql -p 10003:80 -d wordpress
```
Чтобы контейнеры могли быть соединены таким способом, их порты должны быть указаны как открытые при сборке образов. Это делается с помощью команды EXPOSE в файле сборки образа Dockerfile.
## Реестры Docker
Реестр Docker позволяет нескольким пользователям размещать и извлекать образы из центрального хранилища, используя RESTful API.
### Настройка локального реестра Docker
Настройте сервер реестра в своей локальной сети.
```
docker run -d -p 5000:5000 -v $HOME/registry:/var/lib/registry registry:2
```
- команда делает реестр доступным на порту 5000 хоста Docker
- флага ­v он делает папку реестра на вашем хосте (/var/ lib/registry) доступной в контейнере как $HOME/registry

На всех компьютерах, на которых вы хотите получить доступ к этому реестру, добавьте следующее в параметры демона(где HOSTNAME – это имя хоста или IP - адрес сервера вашего нового реестра): --insecure-registry HOSTNAME

## Docker Hub
Docker Hub – это реестр, поддерживаемый Docker Inc.
### Поиск и запуск образа Docker
```
docker search - поиск приложения или инструмента в качестве образа Docker
docker search node
docker pull node - загрузить образ
```
## Использование Docker в качестве легкой виртуальной машины

### Преобразование вашей виртуальной машины в контейнер
Есть виртуальная машина, которую вы хотите преобразовать в образ Docker.
- Архивируйте и скопируйте файловую систему виртуальной машины и упакуйте ее в образ Docker.
- Вы получаете TAR ­файл файловой системы и добавляете (ADD) его в/из образа scratch

Образ scratch – это псевдообраз с нулевым байтом, который вы можете собрать поверх. Обычно он применяется в случаях, когда вы хотите скопировать (или добавить) полную файловую систему, используя файл Dockerfile.
```
FROM scratch
ADD img.tar /
```
### Хост-подобный контейнер
Нужна нормальная хост­среда для своего контейнера с несколькими настроенными процессами и службами.
- Используйте базовый контейнер, предназначенный для запуска нескольких процессов.

**Различия между виртуальными машинами и контейнерами Docker**
- Docker ориентирован на приложения, в то время как вирту- альные машины ­ на операционные системы;
- контейнеры Docker совместно используют операционную систему вместе с другими контейнерами Docker. Напротив, у каждой виртуальной машины есть собственная операци- онная система, управляемая гипервизором;
- контейнеры Docker предназначены для запуска одного ос- новного процесса, а не для управления несколькими набо- рами процессов.
### Разделение системы на микросервисные контейнер
Надо разбить свое приложение на отдельные и более управляемые сервисы
- Создайте контейнер для каждого отдельного служебного процесса
### Управление запуском служб вашего контейнера
Хотите управлять несколькими процессами внутри контейнера.
- Используйте Supervisor для управления процессами в вашем контейнере. Supervisor нужен для управления несколькими процессами в контейнере Docker.
### Подход «сохранить игру»: дешевое управление исходным кодом
Хотите сохранить состояние вашей среды разработки.
- docker commit todobug1 - Фиксация состояния контейнера - Превращает созданный ранее контейнер в образ
### Присвоение тегов
Хотите удобным образом обращаться к коммиту Docker и хранить его.
- Команда docker tag для именования своих коммитов - тег позволяет именовать **конкретную** версию образа
```
docker tag 071f6a36c23a19801285b82eafc99333c76f63ea0aa0b44902c6bae482a6e036 imagename
docker run imagename
```
### Совместное использование образов в Docker Hub
Хотите сделать образ Docker общедоступным
- Используйте реестр Docker Hub
```
docker pull debian:wheezy
docker tag debian:wheezy adev/debian:mywheezy1
docker push adev/debian:mywheezy1
```
### Обращение к конкретному образу в сборках
Хотим сборку созданую из конкретного и неизменного образа
- Укажите идентификатор конкретного образа в своем файле Dockerfile
```
FROM 8eaa4ff06b53
```
Идентификатор образа и его данные должны храниться локально на вашем демоне Docker.

## Сборка образов
### Внедрение файлов в образ с помощью ADD
Хотите скачать и распаковать tar­архив в свой образ в сжатой форме
- Распакуйте и сожмите ваши файлы, используя директиву ADD в файле Dockerfile.
```
ADD my.tar.gz /opt/libeatmydata/
```
Вы можете скачивать tar­ архивы с URL ­адресов, они будут распакованы автоматически, только если хранятся в локальной файловой системе.
## Повторная сборка без кеша
Представьте, что вы изменили свой исходный код и поместили его в репозиторий Git. Новый код не будет извлечен, потому что команда git clone не изменилась.
```
docker build --no-cache - выполнить повторную сборку без использования кеша образов
```
Запрет кеширования может быть полезной проверкой работоспособности после получения окончательного файла Dockerfile
## Запрет кеширования
Хотите аннулировать кеш сборки Docker из определенной точки в сборке
- Добавьте комментарий после команды для аннулирования кеша
```
CMD ["npm","start"] #bust the cache - Docker рассматривает изменение, не являющееся пробелом, в строке
```
## Умный запрет кеширования с помощью build-args
Хотите запретить кеширование по требованию при выполнении сборки
- Используйте директиву ARG в вашем файле Dockerfile, чтобы привести в действие оперативный запрет кеширования.
```
WORKDIR todo
ARG CACHEBUST=no
RUN npm install
```
Если для этой переменной задано значение, которое ранее никогда не использовалось на вашем хосте, кеширование будет отключено из этой точки
```
docker build --build-arg CACHEBUST=${RANDOM}
```
## Умный запрет кеширования с помощью директивы ADD
Хотите запретить кеширование, когда удаленный ресурс изменился.
- Используйте директиву ADD, чтобы запрещать кеширование только при из- менении ответа от URL.
- ADD - кеширует содержимое файла, к которому обращается, и может использовать сетевой ресурс в качестве аргумента. Это означает, что вы можете запрещать кеширование всякий раз, когда меняется вывод веб­запроса.

GitHub API предоставляет полезный ресурс, который может помочь в дан- ном случае. Он содержит URL­адреса для каждого репозитория, которые возвращают JSON для самых последних коммитов. Когда делается новый коммит, содержание ответа изменяется.
```
ADD https://api.github.com/repos/nodejs/node/commits /dev/null
```
## Установка правильного часового пояса в контейнерах
Хотите правильно установить часовой пояс для своих контейнеров.
- Замените файл локального времени контейнера ссылкой на нужный часовой пояс
```
RUN rm -rf /etc/localtime
RUN ln -s /usr/share/zoneinfo/GMT /etc/localtime
```
## Управление локалями
Локаль определяет, какие настройки языка и страны должны использоваться вашими программами.
```
RUN apt-get update && apt-get install -y locales
RUN locale-gen en_US.UTF-8
ENV LANG en_US.UTF-8
ENV LANGUAGE en_US:en
```
## Onbuild и golang
Хотите уменьшить количество шагов при сборке образа, необходимого для приложения.
- Команда ONBUILD, чтобы автоматизировать и инкапсулировать сборку образа.
```
FROM golang:1.7
RUN mkdir -p /go/src/app WORKDIR /go/src/app
CMD ["go-wrapper", "run"]
ONBUILD COPY . /go/src/app - копирует код в контексте Dockerfile в образ
ONBUILD RUN go-wrapper download - скачивает любые зависимости, снова используя команду go-wrapper
ONBUILD RUN go-wrapper install - устанавливает приложение
```
Все три контейнера, созданные с помощью команды ONBUILD, удалены

Результатом этого метода является то, что у вас есть простой способ собрать образ, который содержит только код, необходимый для его запуска, и не более того. Оставляя инструменты сборки вокруг образа, вы не только делаете его больше, чем нужно, но также увеличиваете виды атак для работающего контейнера.
### Запуск контейнеров
## Проверка контейнеров
Хотите узнать IP­адрес контейнера
- Команда docker inspect дает доступ к внутренним метаданным Docker в формате JSON, включая IP­адрес.
## Чистое уничтожение контейнеров
Хотите чисто завершить работу контейнера
- Используйте команду docker stop вместо docker kill для чистого заверше- ния работы контейнера.
### Тома
## Тома Docker: проблемы персистентности
Тома, механизм Docker для управления файлами вне жизненного цикла контейнера. 

Хотите получить доступ к файлам на хосте из контейнера.
- Используйте флаг тома Docker для доступа к файлам хоста в рамках контейнера
```
docker run -v /var/db/tables:/var/data1 -it debian bash
```
Флаг -v указывает на то, что требуется том, внешний по отношению к контейнеру.
## Сохранение истории bash вашего контейнера
Хотите поделиться историей bash вашего контейнера с историей вашего хоста.
- флаг -e, монтирование Docker и псевдоним bash, чтобы автоматически делиться историей bash вашего контейнера с историей хоста.
```
docker run -e HIST_FILE=/root/.bash_history -v=$HOME/.bash_history:/root/.bash_history -ti ubuntu /bin/bash
псевдоним в ~/.bashrc - для удобства :
alias dockbash='docker run -e HIST_FILE=/root/.bash_history -v=$HOME/.bash_history:/root/.bash_history
```
## Контейнеры данных
Хотите использовать внешний том внутри контейнера, но нужно, чтобы только Docker имел доступ к файлам.
- Запустите контейнер данных и используйте флаг --volumes-from при запуске других контейнеров.
```
docker run -v /shared-data --name dc busybox touch /shared-data/somefile
docker run -t -i --volumes-from dc busybox /bin/sh /
```
### Повседневное использование Docker
